/*
 * @lc app=leetcode.cn id=1996 lang=java
 *
 * [1996] 游戏中弱角色的数量
 */

// @lc code=start

/**
 * 我们是要在一个二维数组中，找到 i 和 j，满足(攻击值) i[0] > j[0]，且(防御值) i[1] > j[1]
 * 我们可以按照攻击力进行（升序）排序，再从后往前遍历防御值，并记录遍历过的元素中防御力的最大值，
 * 只要当前元素的防御值小于这个最大值，那么在遍历过的元素中，一定存在一个元素或多个元素，攻击值和防御值均大于当前元素，即，当前元素为弱角色
 * 由于题目要求严格大于，那么对于攻击值相同，防御值不同的元素，我们要保证，防御值高的元素比防御值低的元素后（较迟）遍历到。
 * 例如，[5][3], [5][4], [5][6], [5][5]，这几个元素攻击值相同，我们要保证在排序后，它们在数组中的位置满足如下
 * {...,[5][6], [5][5], [5][4], [5][3], ...}，这样在从后往前遍历的过程中，假如当前记录的防御值的最大值为max
 * 1.如果 max 大于6, 那么这几个元素均会被统计做弱角色，这是合理的
 * 2.如果 max 小于3, 那么在遍历这几个元素的时候，max 会逐渐变大(3 -> 6)，没有元素会被统计做弱角色，这是合理的
 */
class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        // 按照攻击力值序进行排序，如果攻击值相同，则按照防御值降序进行排序
        Arrays.sort(properties, (o1, o2) -> {
            return o1[0] == o2[0] ? o2[1] - o1[1] : o1[0] - o2[0];
        });
        int result = 0;
        int max = 0;
        for (int i = properties.length - 1; i > -1; i--) {
            if (properties[i][1] >= max) {
                max = properties[i][1];
            } else {
                result++;
            }
        }
        return result;
    }
}

// @lc code=end

